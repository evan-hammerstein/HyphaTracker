import cv2
import tifffile as tiff
import numpy as np
from skimage.exposure import rescale_intensity


# Initialize variables
coordinates = []
drawing = False  # Flag for drawing
original_img = None  # Store the current original frame
resized_img = None  # Store resized frame
scale_factor = 1.0  # Scale factor for resizing

# Mouse callback function for area selection and further processing
def select_area(event, x, y, flags, param):
    global coordinates, drawing, resized_img, original_img, scale_factor

    if event == cv2.EVENT_LBUTTONDOWN:  # Start drawing
        drawing = True
        coordinates = [(int(x / scale_factor), int(y / scale_factor))]

    elif event == cv2.EVENT_MOUSEMOVE and drawing:  # Draw rectangle dynamically
        temp_img = resized_img.copy()
        cv2.rectangle(temp_img, (coordinates[0][0], coordinates[0][1]), (x, y), (0, 0, 255), 2)
        cv2.imshow("Image", temp_img)

    elif event == cv2.EVENT_LBUTTONUP:  # Finalize the rectangle
        drawing = False
        coordinates.append((int(x / scale_factor), int(y / scale_factor)))

        x1, y1 = coordinates[0]
        x2, y2 = coordinates[1]
        x1, x2 = min(x1, x2), max(x1, x2)  # Ensure correct cropping order
        y1, y2 = min(y1, y2), max(y1, y2)

        # Crop the selected area
        cropped_image = original_img[y1:y2, x1:x2]

        # Process the cropped area
        processed_cropped = process_frame(cropped_image)  # Apply processing to the cropped frame

        # Display the original cropped and processed cropped frames
        cv2.imshow("Cropped Image", cropped_image)
        cv2.imshow("Processed Cropped Image", processed_cropped)

        # Save the cropped and processed cropped images
        cv2.imwrite("cropped_image.png", cropped_image)
        cv2.imwrite("processed_cropped_image.png", processed_cropped)
        print("Cropped image saved as 'cropped_image.png'")
        print("Processed cropped image saved as 'processed_cropped_image.png'")


# Function to process each frame
def process_frame(frame):
    # Normalize pixel values
    if frame.max() > 255:
        frame = (255 * (frame / frame.max())).astype(np.uint8)

    # Convert to grayscale
    if frame.ndim == 3:
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)

    # Apply bilateral filter
    filtered = cv2.bilateralFilter(frame, d=15, sigmaColor=30, sigmaSpace=25)

    # Apply adaptive Gaussian threshold
    thres_mean = cv2.adaptiveThreshold(filtered, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 2)

    # Divide and invert
    divide = cv2.divide(thres_mean, frame, scale=255)
    divide = 255 - divide

    # Stretch intensity
    maxval = np.amax(divide) / 4
    stretch = rescale_intensity(divide, in_range=(0, maxval), out_range=(0, 255)).astype(np.uint8)

    # Morphological operations for cleaning
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    cleaned = cv2.morphologyEx(stretch, cv2.MORPH_OPEN, kernel)
    filled = cv2.morphologyEx(cleaned, cv2.MORPH_CLOSE, kernel)

    return filled


# Main function to handle frames
def main():
    global original_img, resized_img, scale_factor

    # Load the TIFF file
    tiff_file = r"C:\Users\Harry\OneDrive - Imperial College London\Bioeng\Year 3\Software Engineering\HyphaTracker\timelapse1.tif"
    frames = tiff.imread(tiff_file)

    # Process and display each frame
    for frame_idx, frame in enumerate(frames):
        print(f"Processing frame {frame_idx + 1}")
        processed_frame = process_frame(frame)

        # Prepare the original and resized images for display
        original_img = frame.copy()
        height, width = processed_frame.shape[:2]
        scale_factor = 800 / width  # Resize width to 800 pixels
        resized_img = cv2.resize(processed_frame, (800, int(height * scale_factor)))

        # Show the processed frame
        cv2.imshow("Image", resized_img)
        cv2.setMouseCallback("Image", select_area)

        # Wait for user input
        key = cv2.waitKey(0)
        if key == 27:  # Esc key to exit
            print("Exiting...")
            break
        elif key == ord('s'):  # Save the processed frame
            cv2.imwrite(f"processed_frame_{frame_idx + 1}.png", processed_frame)
            print(f"Saved processed frame {frame_idx + 1}.")

    # Cleanup
    cv2.destroyAllWindows()


# Run the script
if __name__ == "__main__":
    main()
